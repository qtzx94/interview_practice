<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width， initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
        1.三次握手和四次挥手详细介绍
        2.TCP有哪些手段保证可靠交付
            1).确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传
            2).数据校验
            3).数据合理分片和排序:
                    UDP: IP数据报大于1500字节，大于MTU(最大传输单元 Maximum Transmission Unit).这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片，使每一片都小于MTU.
                         而接收方IP层则需要进行数据报的重组.这样就会多做许多事情，而更严重的是，由于UDP的特性，当某一片数据传送中丢失时，接收方便 无法重组数据报.将导致丢弃整个UDP数据报.
                    TCP：会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层
            4).流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失
            5).拥塞控制：当网络拥塞时，减少数据的发送
        3.URL从输入到页面渲染全流程
        4.如何预防中间人攻击
        5.DNS解析会出错吗，为什么
        6.ES6的Set内部实现
        7.如何防止页面劫持 


        TCP/IP是位于传输层上的一种协议，用于在网络中传输数据

        HTTP协议是应用层协议，基于TCP协议，用于包装数据，程序使用它进行通信，可以简单高效的处理通信中数据的传输和识别处理

        TCP：Transmission Control Protocol， 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。
        
        三次握手：
            1.客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。
            2.服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RCVD状态。
            3.客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
        状态码：
            SYN:synchronous   建立联机
            ACK:acknowledgement  确认
            SYN_SENT:请求连接  
            SYN_RCVD:服务端被动打开后，接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。

        三次握手：
            第一次握手：起初两端都处于 CLOSED 关闭状态，Client 将标志位 SYN 置为 1，随机产生一个值 seq = x，并将该数据包发送给 Server，Client 进入 SYN-SENT 状态，等待 Server 确认。
            第二次握手：Server 收到数据包后由标志位 SYN = 1 得知 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack = x + 1，随机产生一个值 seq = y，并将该数据包发送给Client以确认连接请求，Server 进入 SYN-RCVD 状态，此时操作系统为该 TCP 连接分配 TCP 缓存和变量。
            第三次握手：Client 收到确认后，检查 seq 是否为 x + 1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack = y + 1，并且此时操作系统为该 TCP 连接分配 TCP 缓存和变量，并将该数据包发送给 Server，Server 检查 ack 是否为 y + 1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 established 状态，完成三次握手，随后 Client 和 Server 就可以开始传输数据。

        四次挥手：
            第一次挥手：Client 的应用进程先向其 TCP 发出连接释放报文段（FIN = 1，序号 seq = u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待1）状态，等待 Server 的确认。
            第二次挥手：Server 收到连接释放报文段后即发出确认报文段，（ACK = 1，确认号 ack = u + 1，序号 seq = v），Server 进入 CLOSE-WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，Client 到 Server 的连接释放。
                (注：Client 收到 Server 的确认后，进入 FIN-WAIT-2（终止等待2）状态，等待 Server 发出的连接释放报文段。)
            第三次挥手：Server 已经没有要向 Client 发出的数据了，Server 发出连接释放报文段（FIN = 1，ACK = 1，序号 seq = w，确认号 ack = u + 1），Server 进入 LAST-ACK（最后确认）状态，等待 Client 的确认。
            第四次挥手：Client 收到 Server 的连接释放报文段后，对此发出确认报文段（ACK = 1，seq = u + 1，ack = w + 1），Client 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，Client 才进入 CLOSED 状态。

        
        应用场景：
            对网络通讯质量有要求，需要保证数据准确性时，就需要用到TCP协议了，如HTTP、ftp等文件传输协议、或一些邮件传输协议（SMTP、pop等）

        UDP ：User Datagram Protocol 用户数据报协议相比于TCP的面向连接需要反复确认的繁琐步骤，UDP是一中性格特立独行并且主观性超强的非面向连接的协议，使用udp协议经常通信并不需要建立连接，
              它只是负责把数据尽可能快的发送出去，简单粗暴，并且不可靠，而在接收端，UDP把每个消息断放入队列中，接收端程序从队列中读取数据。

        应用场景：
            虽然UDP不可靠，但是它的传输速度快，效率高，在一些对数据准确性要求不高的场景，UDP就变得很有用了，比如qq语音、qq视频。

        socket：也叫嵌套字 ，是一组实现TCP/UDP通信的接口API，也就是说无论TCP还是UDP，通过对scoket的编程，都可以实现TCP/UCP通信，
                作为一个通信链的句柄，它包含网络通信必备的5种信息：
                    1.连接使用的协议
                    2.本地主机的IP地址
                    3.本地进程的协议端口
                    4.远地主机的IP地址
                    5.远地进程的协议端口

                可见，socket包含了通信本方和对方的ip和端口以及连接使用的协议（TCP/UDP）。通信双方中的一方（暂称：客户端）通过scoket（嵌套字）对另一方（暂称：服务端）发起连接请求，
                服务端在网络上监听请求，当收到客户端发来的请求之后，根据socket里携带的信息，定位到客户端，就相应请求，把socket描述发给客户端，双方确认之后连接就建立了。
                因此套接字之间的连接过程有三个步骤：
                    1.服务器监听:服务器实时监控网络状态等待客户端发来的连接请求
                    2.客户端请求:客户端根据远程主机服务器的IP地址和协议端口向其发起连接请求
                    3.连接确认:服务端收到套接字的连接请求之后，就响应请求，把服务端套接字描述发给客户端，客户端收到后一旦确认，则双方建立连接，进行数据交互。

        socket连接一旦建立就保持连接状态，而HTTP连接则不一样，它基于tcp协议的短连接，也就是客户端发起请求，服务器响应请求之后，连接就会自动断开，不会一直保持。

        URL：Uniform Resource Locator 统一资源定位符：web应用绝大部分都是通过HTTP来进行请求的，而URL则是HTTP用来做连接建立和传输数据的一种具体实现

        DNS：Domain Name Server 域名服务器：是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。

        OSI（Open Systems Interconnection Model）网络七层模型：
            应用层 -> 表示层 -> 会话层 -> 传输层 -> 网络层 -> 数据链路层 -> 物理层

            物理层：底层数据传输，如网线；网卡标准。 
            数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。
            网络层：定义IP编址，定义路由功能；如不同设备的数据转发。
            传输层：端到端传输数据的基本功能；如 TCP、UDP。
            会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。
            标识层：数据格式标识，基本压缩加密功能。
            应用层：各种应用软件，包括 Web 应用。

        TCP/IP 模型将 OSI 模型由七层简化为四层，传输层和网络层被完整保留，因此网络中最核心的技术就是传输层和网络层技术。
        TCP/IP 协议中每层技术举例：
            网络访问层：ARP、RARP
            互联网层：ICMP、IP
            传输层：TCP、UDP
            应用层：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS


        因此，当用户在浏览器输入https://www.baidu.com回车时，它经历了以下步骤(域名解析过程)：
            1.浏览器根据地址去本身缓存中查找dns解析记录，如果有，则直接返回IP地址，否则浏览器会查找操作系统中（hosts文件）是否有该域名的dns解析记录，如果有则返回。
            2.如果浏览器缓存和操作系统hosts中均无该域名的dns解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。
            3.请求会先到LDNS（本地域名服务器），让它来尝试解析这个域名，如果LDNS也解析不了，则直接到根域名解析器请求解析
            4.根域名服务器给LDNS返回一个所查询余的主域名服务器（gTLDServer）地址。
            5.此时LDNS再向上一步返回的gTLD服务器发起解析请求。
            6.gTLD服务器接收到解析请求后查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器（比如阿里dns、腾讯dns等）
            7.Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器
            8.返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间有TTL值控制。
            9.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。


        从用户输入URL，到浏览器呈现给用户页面，经过了什么过程:
            1.用户输入URL，浏览器获取到URL
            2.浏览器(应用层)进行DNS解析(如果输入的是IP地址，则忽略这一步)
            3.根据解析出的IP地址+端口，浏览器(应用层)发起HTTP请求，请求中携带(请求头header(也可细分为请求行和请求头)、请求体body)
                header包含：
                    1.请求的方法(get、post、put...)
                    2.协议(http、https、ftp、sftp...)
                    3.目标url(具体的请求路径以及文件名)
                    4.一些必要信息(缓存、cookies之类)
                body包含：
                    1.请求的内容
            4.请求达传输层，tcp协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段来保证传输过程中的安全可靠。通过对大块数据的分割成一个个报文段的方式提供给大量数据的便携传输
            5.到网络层，网络层通过ARP(Address Resolution Protocol，地址解析协议)寻址得到接收方的Mac地址，IP协议把在传输层被分割成一个个数据包传送接收方
            6.数据到达数据链路层，请求阶段完成
            7.接收方在数据链路层收到数据包后，层层传递到应用层，接收方应用层序就获得了请求报文
            8.接收方收到发送方的HTTP请求后，进行请求文件资源(如HTML页面)的寻找并响应报文
            9.发送方接收到响应报文后，如果报文中的状态码表示请求成功，则接受返回的资源(如HTML文件)，进行页面渲染

        浏览器解析渲染页面主要包括以下过程：
            1.浏览器通过HTMLParser根据深度遍历的原则把HTML解析成DOM Tree。
            2.将CSS解析成CSS Rule Tree（CSSOM Tree）。
            3.根据DOM树和CSSOM树来构造render Tree。
            4.layout：根据得到的render tree来计算所有节点在屏幕的位置。
            5.paint：遍历render树，并调用硬件图形API来绘制每个节点。

        对于点对点之间的通信，按照消息传送的方向与时间关系，通信方式可分为单工通信，半双工通信以及全双工通信

        单工通信：
            单工通信（Simplex Communication）是指消息只能单方向传输的工作方式。
            在单工通信中，通信的信道是单向的，发送端与接收端也是固定的，即发送端只能发送信息，不能接收信息；接收端只能接收信息，不能发送信息。基于这种情况，数据信号从一端传送到另外一端，信号流是单方向的。
            例如：生活中的广播就是一种单工通信的工作方式。广播站是发送端，听众是接收端。广播站向听众发送信息，听众接收获取信息。广播站不能作为接收端获取到听众的信息，听众也无法作为发送端向广播站发送信号。
            通信双方采用“按——讲”（Push To Talk，PTT）单工通信属于点到点的通信。根据收发频率的异同，单工通信可分为同频通信和异频通信 。
        半双工通信：
            半双工通信（Half-duplex Communication）可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替地进行。
            在这种工作方式下，发送端可以转变为接收端；相应地，接收端也可以转变为发送端。但是在同一个时刻，信息只能在一个方向上传输。因此，也可以将半双工通信理解为一种切换方向的单工通信。
            例如：对讲机是日常生活中最为常见的一种半双工通信方式，手持对讲机的双方可以互相通信，但在同一个时刻，只能由一方在讲话。
        全双工通信
            全双工通信（Full duplex Communication）是指在通信的任意时刻，线路上存在A到B和B到A的双向信号传输。 全双工通信允许数据同时在两个方向上传输，又称为双向同时通信，
            即通信的双方可以同时发送和接收数据。在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送。全双工方式无需进行方向的切换，
            因此，没有切换操作所产生的时间延迟，这对那些不能有时间延误的交互式应用（例如远程监测和控制系统）十分有利。这种方式要求通讯双方均有发送器和接收器，
            同时，需要2根数据线传送数据信号。（可能还需要控制线和状态线，以及地线）。

        WebSocket (WS)是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。
        WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：
            WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。
            HTTP协议：
                http1.1以下版本，http连接为短连接，tcp连接发送信息等待接受信息后断开，为单工协议。
                http1.1是半双工，通过开启keep-alive建立长连接，出现多路复用，可先后发送多个http请求，不用等待回复，但是回复按顺序一个一个回复。(当前主流协议)
                http2.0是全双工，一个消息发送后不用等待接受，第二个消息可以直接发送。
            注：WSS（Web Socket Secure）是WebSocket的加密版本。

        很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。
        这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。
        HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。

</body>
</html>
