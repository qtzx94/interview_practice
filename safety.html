<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>安全</title>
</head>
<body>
    1.CSRF（Cross-site request forgery）通常被称为跨站请求伪造：
        攻击原理：
                用户访问受信任网站A并且登录，网站A会下发cookie信息给浏览器，此时当用户访问网站B时（未退出网站A的情况下），返回一些攻击性代码，并诱导用户访问网站A，
                浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带cookie信息，向网站A发起请求，网站A不知道该请求其实是网站B发起的，
                所以会根据用户的cookie信息和用户的权限处理该请求，导致来自网站B的恶意代码被执行
        防御措施：（CSRF能攻击成功是因为黑客完全可以伪造用户的请求，该请求中所有的用户验证信息都存在cookie中，所以黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie信息来通过安全验证，
                    所以要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在与cookie中。）

                1.Token验证：可以在http请求中以参数的形式加入一个随机产生的token，并且在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求
                         优点：这种方法要比检查Referer要安全一些，token可以在用户登陆后产生并放于session之中，然后在每次请求时把token从session中拿出，与请求中的token进行比对。
                         缺点：难点在于如何把token以参数的形式加入请求。对于GET请求，token将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 
                              而对于POST请求来说，要在form的最后加上 <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>，这样就把token以参数的形式加入请求了。
                              但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，
                              使用javascript遍历整个dom树，对于dom中所有的a和form标签后加入token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的html代码，这种方法就没有作用，还需要程序员在编码时手动添加token。
                              该方法还有一个缺点是难以保证token本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。
                              由于系统也会在这个地址后面加上token，黑客可以在自己的网站上得到这个token，并马上就可以发动CSRF攻击。为了避免这一点，系统可以在添加token的时候增加一个判断，
                              如果这个链接是链到自己本站的，就在后面添加token，如果是通向外网则不加。不过，即使这个csrftoken不以参数的形式附加在请求之中，黑客的网站也同样可以通过Referer来得到这个token值以发动CSRF攻击。
                              这也是一些用户喜欢手动关闭浏览器Referer功能的原因。

                2.Referer验证：http头中有个字段叫Referer，记录了该http请求的来源地址，如果黑客要进行CSRF攻击，他只能在自己的网站构建请求，通常情况下，访问一个安全受限页面的请求来自于同一个网站，所以验证Referer值是否是当前网站自己的域名，如果相同，则合法，不同，则可能是黑客的CSRF攻击
                         优点：简单易行，网站的普通开发人员不需要操心CSRF的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查Referer的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。
                         缺点：Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。
                              使用验证Referer值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如IE6或FF2，目前已经有一些方法可以篡改Referer值。
                              即便是使用最新的浏览器，黑客无法篡改Referer值，这种方法仍然有问题。因为Referer值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心Referer值会把组织内网中的某些信息泄露到外网中。
                              因此，用户自己可以设置浏览器使其在发送请求时不再提供Referer。当他们正常访问银行网站时，网站会因为请求没有Referer值而认为是CSRF攻击，拒绝合法用户的访问。

                3.隐藏令牌：和token验证原理差不多，只不过不是把token以参数的形式至于http请求之中，而是放在http头的自定义属性里，使用XMLHttpRequest这个类，给所有的请求增加csrftoken这个http头属性，把token值放入其中，
                         优点：解决了Token验证方法在请求中加入token的不便，同时，通过XMLHttpRequest请求的地址不会被记录到浏览器的地址栏，不用担心token会透过Referer泄露到其他网站中
                         缺点：局限性非常大。XMLHttpRequest请求通常用于Ajax方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，
                         从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行CSRF防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为XMLHttpRequest请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。

    2.XSS（Cross-site scripting） 跨域脚本攻击
        攻击原理：对网页注入可执行代码且成功地被浏览器执行（比较常见场景是在博客，论坛等社交网站上，提交恶意攻击代码）
        防御措施：
                1.在表单提交或者url参数传递前，对需要的参数进行过滤
                2.过滤用户输入的 检查用户输入的内容中是否有非法内容。如<>（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&（& 符号）、+（加号）等。、严格控制输出

    3.CSRF和XSS区别：
        XSS是向页面注入js并运行，在js中做一些攻击
        CSRF是利用漏洞去执行某些接口，并且依赖用户的登录状态
</body>
</html>